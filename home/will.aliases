# Will's alias file for all SH-derived shells (SH, ASH, ZSH, BASH, etc.),
# contains basic stuff for interactive and non-interactive shells

# version 2018-07-27
# - update pushd to ignore ZSH if done in ENV and have a safer silence

################################################################################
# DEBUG & ALIAS GUARD (the command -v checks break on re-run)
################################################################################
# If running interactively, set veriable to print debug
secho () {
  case $- in
    *i*) echo "$@";;
      *) return 1;;
  esac
}


if command -v wills_supper_hacky_guard_alias > /dev/null 2>&1; then
  secho "Not re-sourcing will.aliases"
  return 0
  exit 0
else
  secho "running will.aliases"
  alias wills_supper_hacky_guard_alias='echo hi'
fi

if command -v setopt > /dev/null 2>&1; then
  set is_zsh
fi

################################################################################
# Portability stuff                           should be before almost everything
################################################################################

# keep dirstack stuff where it is
if command -v pushd > /dev/null 2>&1; then
  if [ $is_zsh ] && [ setopt | grep autopushd > /dev/null 2>&1 ]; then
    dirstack="automatic"
  else
    dirstack="present"
  fi
else
  dirstack="missing"
fi

# Alias favorite programs that may be missing
# more/less
if ! command -v 'less' > /dev/null 2>&1; then
  alias less='more'
else
  alias more='less'
fi

# vi/vim
if ! command -v 'vim' > /dev/null 2>&1; then
  alias vim='vi'
fi

if ! command -v 'vi' > /dev/null 2>&1; then
  alias vi='vim'
fi

# nano -> pico -> vi(m) waterfall
if ! command -v 'nano' > /dev/null 2>&1; then
  if command -v 'pico' > /dev/null 2>&1
  then
    alias nano='pi\co -w'
  else
    alias nano='vim'
  fi
fi

# pico -> vi(m) waterfall and force -w
if ! command -v 'pico' > /dev/null 2>&1; then
  alias pico='vim'
else
  alias pico='pico -w'
fi

# for scp compatibility in busybox environments
if ! command -v 'groups' > /dev/null 2>&1; then
  alias groups='id -nG'
fi

# some du's don't have -h (human readable), but default to it if it's there
if ! du -h /dev/console > /dev/null 2>&1; then
  alias du='du -h'
fi

# same for df (though -h seems more common)
if ! df -h / > /dev/null 2>&1; then
  alias df='df -h'
fi

# UPPERCASE/lowercase conversions
tmp_externalcase=0
case $0 in
  *bash)
          if [ "$BASH_VERSINFO" -lt 4 ]; then
            tmp_externalcase=1
          else
            lc () { echo "${@,,}"; }
            uc () { echo "${@^^}"; }
          fi
          ;;
   *zsh)
          lc () { echo "${*:l}"; }
          uc () { echo "${*:u}"; }
          ;;
      *) tmp_externalcase=0;;
esac

if [ $tmp_externalcase -eq 1 ]; then
  command -v 'typeset' > /dev/null 2>&1
  if [ $? -eq 0 ] && [ "test" = "$(typeset -l 'TEST')" ]; then
    alias lc='typeset -l'
    alias uc='typeset -u'
  fi
  # TODO: waterfall beyond this, see https://stackoverflow.com/questions/2264428/how-to-convert-a-string-to-lower-case-in-bash
fi

unset tmp_externalcase

################################################################################
# Program overrides
################################################################################
# zgrep will search uncompressed and compressed files, default to regexes
if command -v 'z\grep' > /dev/null 2>&1; then
  alias zgrep='zgrep --color=auto -E'
else
  alias zgrep='grep --color=auto -E'
fi

alias screen='screen -xR'
alias sscreen='unset STY; scre\en'

# assh, even if go/bin isn't in gopath
if command -v 'assh' > /dev/null 2>&1; then
  alias ssh='assh wrapper ssh'
elif [ -x "$HOME/go/bin/assh" ]; then
  alias ssh="$HOME/go/bin/assh wrapper ssh"
fi

################################################################################
# one-letter wonders (except for the ls group)     depend on portability aliases
################################################################################
alias m='less'
alias c='clear'
alias f='find -iname'
# Conditionals will alias htop, zgrep, nano, and vim later if they don't exist
alias e='nano'
alias v='vim'
alias t='htop'
alias g='zgrep'
# Dir-stack is rarer
if [ ! $dirstack = "missing" ]; then
  alias p='popd'
  alias d='dirs -v'
fi

################################################################################
# ls commands                                  only depend on the first one here
################################################################################
alias ls='ls -AFh --color=auto'
alias l1='l\s -1'
alias la='ls -a'
alias ll='ls -l'
alias lr='ll -r'
alias lt='ll -t'
alias ltr='ll -tr'
alias l='ll'

################################################################################
# misc aliases                                     depend on portability aliases
################################################################################
alias nukeme='kill -9 `ps -u $USER -o pid --no-heading`'
alias psa='ps u $USER'
# tar
alias tu='tar -cvzf'
alias tx='tar -xvf'

# force of habit
alias type='command -V'
alias which='command -V'
alias what='command -V'
alias cls='clear'

if command -v 'gitk' > /dev/null 2>&1; then
  alias gci='git citool &'
fi

################################################################################
# file/directory aliases                                             independent
################################################################################
alias rp='readlink -f'
alias up='cd ..'
alias up2='cd ../..'
alias upp='cd ../..'
alias up3='cd ../../..'
alias uppp='cd ../../..'
alias up4='cd ../../../..'
alias upppp='cd ../../../..'
alias up5='cd ../../../../..'
alias uppppp='cd ../../../../..'
alias mkdir='mkdir -p'
alias md='mkdir -p'
alias cp='cp -a'

# more in the "functionland" section

################################################################################
# functionland
################################################################################

# replace pushd with cd if the shell doesn't implement directory stack
# note: this is mostly for functions... I don't use pushd and expect cd to push
if [ $dirstack = "present" ]; then
  # Tell pushd to shut the hell up (but allow errors)
  pushd () {
    command pushd $* > /dev/null
  }
elif [ $dirstack = "missing" ]; then
  # just alias it to cd
  pushd () {
    command cd $*
  }
fi

# smart CD to the path containing a file if file given
cd() {
  if [ -z $1 ]
  then
    # no arguments has a different default meaning to pushd, but we still want the cd behavior
    # TODO: check if this has any issue for ZSH (autopushd)
    pushd ~
  elif [ -z $2 ]
  then
    if [ -f $1 ]
    then
      pushd `dirname $1`
    else
      pushd $1
    fi
  else
    # multiple arguments overrides this and falls back to the regular cd
    command cd $*
  fi
}

# cd and/or less is simpler with smartcd
# Note: cdl can be "odd" when the path is a link etc. since it needs to use
#       readlink to get the full path. This could be made better by path-parsing,
#       but I'm too lazy to figure out how to make that portable
cdl () {
  local file=`readlink -f $1`
  cd $1
  less $file
}

#mkcd=mkdir then CD (doesn't need smart CD since we just made the directory)
mkcd () {
  mkdir "$@"
  pushd "$@"
}

# smart background remove
rmr () {
  mkdir tombstone > /dev/null 2>&1
  local tombstone=`readlink -f tombstone`
  mv $* $tombstone/ > /dev/null 2>&1
  for x in $*
  do
    rm -rf $tombstone/x
  done
  rmdir $tombstone > /dev/null 2>&1
}

# dua (du all): use a loop to prevent globbing errors on the pickier shells
# finally, we want to avoid using du on certain dirs (most notably snapshots)
dua () {
  for x in .[!.]* ..?* *
  do
    if [ -e $x && $x != ".snapshot/" ]
    then
      du -sx $x
    fi
  done
}

# Add & to common guis
if command -v 'gitk' > /dev/null 2>&1; then
  gitk () {
    command gitk $* &
  }
fi
if command -v 'kate' > /dev/null 2>&1; then
  kate () {
    command kate $* &
  }
fi
if command -v 'gedit' > /dev/null 2>&1; then
  gedit () {
    command gedit $* &
  }
fi
if command -v 'gvim' > /dev/null 2>&1; then
  gvim () {
    command gvim $* &
  }
fi
